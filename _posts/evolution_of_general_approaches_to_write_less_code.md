
Developers love writing code but they also seem to want to write as little code as possible. Throughout the (relatively) short history of Computer Programming and Software Engineering, a number of breakthroughs have helped developers to write less code and automate more of the process of building large, complex software systems that either could not have been built in the past or would have cost orders of magnitude more. Some of these solutions are generally applicable and can be leveraged by almost any software developer, in any application domain or programming language. Examples include frameworks and StackOverflow. Other approaches target particular contexts. That is the case of advances such as no-code platforms, domain-specific languages, and program generators. 
What all these solutions have in common is the raising of the level of abstraction at which developers must think about the systems they build, removing part of the cognitive burden related to software development and the manual and intelectual effort of writing the code. 

Software development tools powered by large language models are, without fear of hyperbole, a groundbreaking advance that will enable software developers to achieve enormous gains in productivity. They likely will shift the emphasis of development from writing code (and its ancillary activities) to reviewing, testing, and integrating generated snippets. In this post I briefly examine some of the breakthroughs that took us from assembly language to LLM-based technology. I focus on what I believe are general purpose advances that strongly changed how developers built and build software and saved them significant effort in the specific task of writing code. 

**Compilers and high-level languages**. Compilers made it possible to program in a high-level language that is closer to natural language. They enabled the construction of systems that are much more complex, reliable, and maintainable than those written in Assembly and they also enabled developers to do that much faster than used to be possible before. Instructions in a high-level language abstract way many of the details of how the underlying hardware works, often encompass the execution of multiple instructions at the machine level, and can be ported across different hardware platforms, as long as there are compilers for said language in those platforms. According to Brooks in his 1986 essay "No Silver Bullet: Essence and Accidents in Software Engineering", the invention of high-level languages was, at the time, the single most important factor in improving developers productivity. 


Libraries: The portability afforded by high-level programming languages and the possibility of separate compilation of parts of a program promote code reuse.

Frameworks: architecture and code reuse.

Code autocompletion: Java? Less reference to documentation. Less repetitive work.

StackOverflow
The crowd! Ready-made solutions to an extremely wide range of programming problems that require little effort to be reused. 

LLM-based tools


%--------------------------------------


