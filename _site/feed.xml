<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fernando Castor&#39;s rants</title>
    <description>The opinions expressed here are the sole responsibility of the author.
</description>
    <link>http://fernandocastor.github.io/</link>
    <atom:link href="http://fernandocastor.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 15 Dec 2015 14:58:47 -0300</pubDate>
    <lastBuildDate>Tue, 15 Dec 2015 14:58:47 -0300</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Swift is now open source. Obviously.</title>
        <description>&lt;p&gt;Apple has a long history with the Objective-C programming language. In February 1997, it acquired Steve Jobs’ company, NeXT, which employed Objective-C since the late 80s as the programming language of choice for the development of its operating system, NeXTStep. Since NeXTStep became the basis for Apple’s MacOS X, Objective-C also became the  language of choice for Apple development. It was the programming language of the MacOS and the iOS. It remained on top for the next 17 years, reaching a point where it became one of the most popular programming languages in use. &lt;/p&gt;

&lt;p&gt;It all started to change with the announcement of &lt;a href=&quot;http://www.swift.org/&quot;&gt;Swift&lt;/a&gt; in the &lt;a href=&quot;http://www.apple.com/apple-events/june-2014/&quot;&gt;keynote&lt;/a&gt; of WWDC 2014. At the time, &lt;a href=&quot;http://www.apple.com/br/pr/bios/craig-federighi.html&quot;&gt;Craig Federighi&lt;/a&gt;, Apple’s VP of Software Engineering stated that ``We’ve used Objective-C for 20 years, and we love it. But we wondered what we could do without the baggage of C.’’ Fast-forward one year and in WWDC 2015’s &lt;a href=&quot;http://www.apple.com/live/2015-june-event/&quot;&gt;keynote&lt;/a&gt; (about 69m15s in), the same Federighi announced that Swift 2, which would still be released in 2015, would be open source. This was very big news. The size of the cheer that those news got from the public at WWDC hints at their impact. I was cheering like a fanboy as well. 
However, as is usually the case, in retrospect, this was an obvious decision, one that should have been taken a long time ago. &lt;/p&gt;

&lt;h3 id=&quot;enabling-vs-differentiating&quot;&gt;Enabling vs. Differentiating&lt;/h3&gt;

&lt;p&gt;In his 2005 article, &lt;a href=&quot;http://firstmonday.org/ojs/index.php/fm/article/viewArticle/1470/1385&quot;&gt;The Emerging Economic Paradigm of Open Source&lt;/a&gt;, &lt;a href=&quot;http://perens.com/&quot;&gt;Bruce Perens&lt;/a&gt;, one of the creators of the &lt;a href=&quot;https://opensource.org/osd-annotated&quot;&gt;Open Source Definition&lt;/a&gt; and of the &lt;a href=&quot;https://www.debian.org/social_contract.en.html&quot;&gt;Debian Social Contract&lt;/a&gt;, highlighted two different roles that software takes within an organization. It may be an &lt;strong&gt;enabling technology&lt;/strong&gt; or a &lt;strong&gt;business differentiation&lt;/strong&gt;. Enabling technologies help an organization to operate. The organization does not directly profit from enabling technologies, nor differentiates itself from competition. Instead, enabling technologies are cost centers that the organization has to bear in order reach its business goals. &lt;/p&gt;

&lt;p&gt;A representative example of enabling technology is &lt;a href=&quot;https://products.office.com/&quot;&gt;Microsoft Office&lt;/a&gt;. It may be useful for a company to be more productive, but any company with resources to acquire it can benefit from that added productivity. Less obvious examples are infrastructure software necessary to run businesses like &lt;a href=&quot;http://www.facebook.com&quot;&gt;Facebook&lt;/a&gt;, &lt;a href=&quot;http://www.google.com&quot;&gt;Google&lt;/a&gt;, and &lt;a href=&quot;http://www.amazon.com&quot;&gt;Amazon&lt;/a&gt;. Since their infrastructures operate on a scale never seen before, they cannot simply acquire their infrastructure software and must build much of it in-house. However this kind of software is still a cost center. For example, even though Facebook’s &lt;a href=&quot;http://cassandra.apache.org/&quot;&gt;Cassandra&lt;/a&gt; is a very sophisticated distributed storage system, Facebook’s business does not center around this technology. The same goes for Amazon’s &lt;a href=&quot;http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html&quot;&gt;DynamoDB&lt;/a&gt; storage system. On the other hand, some pieces of infrastructure are clearly business differentiators. Examples include the most sophisticated parts of Google’s search engine software and Amazon’s recommendation system. Much of the profit from these companies comes from the very good jobs these pieces of differentiating technology perform. The same goes for Microsoft Office, from Microsoft’s perspective. Much of its &lt;a href=&quot;http://www.theregister.co.uk/2015/04/24/microsoft_q3_2015_results_azure_cloud/&quot;&gt;profit&lt;/a&gt; comes from both the retail and service-based versions of Office. For users, Office is an enabling technology but, for Microsoft, it is a business differentiator. Perens summarizes this point in his article: &lt;/p&gt;

&lt;p&gt;&lt;em&gt;``An important indicator of whether software is differentiating is whether or not your competitor can get the same software. Neither Microsoft software nor Linux and Open Source can help you differentiate your business for long, because they are available to everyone. They differentiate against each other, they just don’t differentiate your business.’’&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;back-to-swift&quot;&gt;Back to Swift&lt;/h3&gt;

&lt;p&gt;Why is this distinction between Enabling Software and Differentiating Software important? Because &lt;strong&gt;enabling software should always be open source&lt;/strong&gt;, since an organization does not profit from not making it so. Since enabling software is a cost center, making it open source distributes costs and risks between the organization owning the software and the larger community that may have an interest on it. This community may comprise independent developers, governments, non-profits, and for-profit organizations. It helps disseminate software and improve it, making it more portable, more reliable, more well-known, and more widely used. This is the reasoning behind the decisions of organizations such as Facebook, Google, and Microsoft when making software technologies such as Cassandra, &lt;a href=&quot;https://www.android.com/&quot;&gt;Android&lt;/a&gt;, and &lt;a href=&quot;https://news.microsoft.com/2014/11/12/microsoft-takes-net-open-source-and-cross-platform-adds-new-development-capabilities-with-visual-studio-2015-net-2015-and-visual-studio-online/&quot;&gt;.NET&lt;/a&gt; open source. &lt;/p&gt;

&lt;p&gt;It is no surprise, thus, that last Friday, December 4th 2015, Apple has made Swift open source. It is easy to see that when we analyze Apple’s  &lt;a href=&quot;http://www.apple.com/pr/library/2015/10/27Apple-Reports-Record-Fourth-Quarter-Results.html&quot;&gt;earnings reports&lt;/a&gt;. MacRumors compiled a nice &lt;a href=&quot;http://www.macrumors.com/2015/10/27/q4-2015-earnings/&quot;&gt;graph&lt;/a&gt; breaking down the contributions of different sources of revenue to Apple’s overall earnings. According to this graph, the vast majority of Apple’s revenue in the last few years came from iPhone sales, followed by Mac sales, and a broad category named Services, which covers the iTunes store, the App Store and, more recently, Apple Music. In other words, Apple is mainly a &lt;strong&gt;hardware&lt;/strong&gt; company (iPhone, Mac, iPad) which also profits from services. It is in its best interest to have as much high quality software as possible in its platforms (iOS, MacOS and, more recently, watchOS and tvOS) because this makes them more valuable. Hence, it is fair to say that &lt;strong&gt;to Apple, Swift is an enabling technology.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;One interesting question, in this context, is why haven’t Apple made Objective-C open source, instead of proposing a new language. Well, I have no good answer for that, but there are at least two obvious (again :) factors. The first one is that Objective-C is a painful language. Simply typing “Objective-C sucks” in Google shows that this opinion is shared by more than a few developers. In contrast, if one types “Java sucks” in Google, although quite a few results do show up, some of them are actually defending Java, instead of attacking it. The second one is that even Apple believes that Objective-C has overstayed its welcome. Craig Federighi described Swift as a language to be used in the next 20 years. I may be seeing too much here, but 20 years is approximately the time Apple has spent with Objective-C. Maybe a company that is almost universally seen is very innovative does not want to be thought of as a company that cannot let go of old technology. Thus, simply making Objective-C open source would not make the cut. A new language would be necessary first, one that could address some of the shortcomings of 
Objective-C development. &lt;/p&gt;

&lt;h3 id=&quot;open-source-swift-is-great-news&quot;&gt;Open source Swift is great news!&lt;/h3&gt;

&lt;p&gt;Besides being obvious, I also think that Apple making Swift open source is &lt;strong&gt;great news&lt;/strong&gt;. First of all because it will make the language more widely available (even Linux is &lt;a href=&quot;https://github.com/apple/swift&quot;&gt;supported&lt;/a&gt;). Swift is, IMHO, so far the language which best integrates object-oriented and functional programming. The two approaches merge seamlessly and synergistically. Swift has classes, protocols, protocol extensions, algebraic datatypes disguised as enumerations, &lt;code&gt;Maybe&lt;/code&gt;s (&lt;code&gt;Optional&lt;/code&gt;s), closures, and partial function application. Having the source code available makes it possible to experiment with these features (and new ones) on a completely different level. How long until we have the first object-oriented programming language supporting full-fledged &lt;a href=&quot;http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html&quot;&gt;monads&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;Open source Swift is also desirable for researchers. They won’t have such a hard time conducting studies targeting the Apple ecosystem, since there’ll be tools allowing us to analyze programs for this ecosystem. For example, prior to December 4th, to conduct a simple study to collect basic object-oriented programming quality metrics from Swift programs, one would have to build a lexer, a parser and, depending on the degree of precision desired, a type checker. Now, all of this comes for free. A researcher can focus on the information she actually wants to gather and abstract way the basics. &lt;/p&gt;

&lt;p&gt;An additional reason why going open source is great news for Swift is that the community can take control. Being open source means that Swift is forkable. In Github, a simple press of a button produces a complete copy of the entire Swift codebase that can envolve independently from Apple’s version. This allows for free experimentation with the language’s toolset, improving this toolset and making it available in new platforms. It makes me wonder when the first Android app written entirely in Swift will become available. &lt;/p&gt;

&lt;p&gt;It is also worth considering the choice of license for Swift. Apple has selected the &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;&gt;Apache License v.2.0&lt;/a&gt;. This is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Permissive_free_software_licence&quot;&gt;permissive open source license&lt;/a&gt;, which means that developers are free to not only execute, read, modify, and distribute the source code of Swift, but also to close the source code if they believe this can be beneficial. This is good because this kind of license allows all the community to benefit, not only those who defend open source. Moreover, it is to some extent consistent with Apple’s past interactions with open source in the context of the Darwin operating system, which was an amalgam of NeXTStep and the BSD operating systems. The later uses the &lt;a href=&quot;https://opensource.org/licenses/BSD-3-Clause&quot;&gt;BSD&lt;/a&gt; license, which is also permissive.  Darwin was distributed according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Apple_Public_Source_License&quot;&gt;Apple Public Source&lt;/a&gt; license, not a permissive license but still not a strong &lt;a href=&quot;http://www.gnu.org/licenses/copyleft.en.html&quot;&gt;copyleft&lt;/a&gt; license, such as the &lt;a href=&quot;http://www.gnu.org/licenses/gpl-3.0.en.html&quot;&gt;GPL&lt;/a&gt;. Darwin was the basis for the first versions of the MacOS X operating system.&lt;/p&gt;

&lt;h3 id=&quot;concluding&quot;&gt;Concluding&lt;/h3&gt;

&lt;p&gt;In retrospect, Swift should have been open-sourced from the outset. It wasn’t but Apple has quickly fixed this mistake. Now a world of possibilities is open for developers and researchers interested in Apple’s ecosystem. Some of my students and colleagues have already started pursuing research targeting Swift and I am excited to see what will appear in the next few years. &lt;/p&gt;
</description>
        <pubDate>Tue, 08 Dec 2015 09:45:00 -0300</pubDate>
        <link>http://fernandocastor.github.io/general/2015/12/08/swift.html</link>
        <guid isPermaLink="true">http://fernandocastor.github.io/general/2015/12/08/swift.html</guid>
        
        
        <category>general</category>
        
      </item>
    
      <item>
        <title>Haskell in Green Land: Analyzing the energy behavior of a purely functional language</title>
        <description>&lt;p&gt;&lt;em&gt;This post is a summary of a paper currently under submission. This work was conducted in cooperation with my colleague &lt;a href=&quot;http://www.di.ubi.pt/~jpf/&quot;&gt;Joao Paulo Fernandes&lt;/a&gt; from &lt;a href=&quot;http://www.ubi.pt&quot;&gt;UBI&lt;/a&gt;, Portugal, and students &lt;a href=&quot;https://twitter.com/_luisgabriel&quot;&gt;Luís Gabriel Lima&lt;/a&gt;, &lt;a href=&quot;https://sites.google.com/a/cin.ufpe.br/frsoares/&quot;&gt;Francisco Soares-Neto&lt;/a&gt;, and Paulo Lieuthier from &lt;a href=&quot;http://www.ufpe.br&quot;&gt;UFPE&lt;/a&gt; and Gilberto Melfe from UBI.&lt;/em&gt; &lt;/p&gt;

&lt;p&gt;Researchers have been studying energy efficiency for hardware components for a long time. However, more than 20 years ago, the well-known paper [&lt;a href=&quot;http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=335012&quot;&gt;1&lt;/a&gt;] by Tiwari, Malik, and Wolfe stated that &lt;em&gt;it is either impractical or impossible to use the lower level tools to estimate the power cost of the software component of the system&lt;/em&gt;, in the context of embedded software. Apparently, lots of people agree, since the paper has more than &lt;a href=&quot;https://scholar.google.com.br/scholar?cites=11094575625336609457&amp;amp;as_sdt=2005&amp;amp;sciodt=0,5&amp;amp;hl=pt-BR&quot;&gt;1100 citations&lt;/a&gt; at &lt;a href=&quot;http://scholar.google.com&quot;&gt;Google Scholar&lt;/a&gt;. In the last few years, the growing worldwide movement towards sustainability, including &lt;a href=&quot;http://sustainabilitydesign.org/&quot;&gt;sustainability in software&lt;/a&gt;, combined with the systemic nature of energy efficiency as a quality attribute and the widespread adoption of mobile, battery-reliant devices have motivated the study of the energy impact of application software in execution. This tendency has led researchers to evaluate existing techniques, tools, and languages for application development from an energy-centric perspective. Recent work has studied the effect that factors such as code obfuscation [&lt;a href=&quot;http://dx.doi.org/10.1109/ICSME.2014.35&quot;&gt;2&lt;/a&gt;], Android API calls [&lt;a href=&quot;http://dx.doi.org/10.1145/2597073.2597085&quot;&gt;3&lt;/a&gt;], object-oriented code refactorings [&lt;a href=&quot;http://dx.doi.org/10.1145/2652524.2652538&quot;&gt;4&lt;/a&gt;], constructs for concurrent execution [&lt;a href=&quot;http://dx.doi.org/10.1145/2714064.2660235&quot;&gt;5&lt;/a&gt;], and data types [&lt;a href=&quot;http://doi.org/10.1007/978-3-662-46675-9_21&quot;&gt;6&lt;/a&gt;] have on energy efficiency. Analyzing the impact of different factors on energy is important for software developers and maintainers. It can inform their decisions about the best and worst solutions for a particular context. Moreover, it is important to make developers aware that seemingly small modifications can yield considerable gains in terms of energy. For example, a study [&lt;a href=&quot;http://dx.doi.org/10.1145/2597073.2597085&quot;&gt;3&lt;/a&gt;] by Vasquez et al. has discovered that some Android API calls consume 3000 of times more energy than the average Android API call. These API calls should clearly be avoided if possible and energy is an important requirement.&lt;/p&gt;

&lt;p&gt;We have decided to explore an additional dimension. More specifically, we study the energy behavior of programs written in a lazy, purely functional language, namely, Haskell. Functional languages, in general, include a number of features that are not generally available in imperative programming languages. In particular, Haskell has mature implementations of sophisticated features such as laziness, partial functional application, software transactional memory, tail recursion, and a &lt;a href=&quot;https://en.wikipedia.org/wiki/Kind_(type_theory)&quot;&gt;kind system&lt;/a&gt;. Furthermore, recursion is the norm in Haskell programs and side effects are restricted by the type system of the language. Due to all these differences it is possible that programs written in such a language behave differently from those written in imperative languages, from an energy perspective. As a sidenote, if you’re not familiar with Haskell, I highly recommend you spend some quality time with it. It’s a language that, in the worst case, will make you think a little differently about programming and, in the best, will make you fall in love head over heels. Miran Lipovaca’s great &lt;a href=&quot;http://learnyouahaskell.com/chapters&quot;&gt;book&lt;/a&gt; is a nice starting point.&lt;/p&gt;

&lt;p&gt;We analyze the energy efficiency of Haskell programs from two different perspectives: strictness and concurrency. By default, expressions in Haskell are lazily evaluated, meaning that any given expression will only be evaluated when it is first necessary. This is different from most programming languages, where expressions are evaluated strictly and possibly multiple times. In Haskell, it is possible to force strict evaluation in contexts where this is useful. This is very important to analyze the performance and energy efficiency of Haskell programs. As for concurrency, previous work [&lt;a href=&quot;http://dx.doi.org/10.1145/2714064.2660235&quot;&gt;5&lt;/a&gt;,&lt;a href=&quot;http://dx.doi.org/10.1016/j.jocs.2013.01.005&quot;&gt;7&lt;/a&gt;] has demonstrated that concurrent programming constructs can influence energy consumption in unforeseen ways. We attempt to shed more light on this complex subject. More specifically, we address the following high-level research question:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;To what extent can we save energy by refactoring existing Haskell programs to use different data structure implementations or concurrent programming constructs?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To gain insight into the answer to this question, we conducted two complementary empirical studies. In the first one we analyzed the performance and energy behavior of several benchmark operations over 15 different implementations of three different types of data structures. Even though Haskell has several implementations of well-known &lt;a href=&quot;https://hackage.haskell.org/package/EdisonAPI-1.3/docs/Data-Edison.html&quot;&gt;data structures&lt;/a&gt;, we are not aware of any experimental evaluation of these implementations. In the second one we assessed three different thread management primitives and three constructs for data sharing using nine benchmarks and multiple experimental configurations. To the best of our knowledge, this is the first study of its kind targeting Haskell’s concurrent programming constructs. Overall, experimental space exploration comprises more than 2000 configurations and 20000 executions.&lt;/p&gt;

&lt;p&gt;We found that &lt;strong&gt;small changes can make a big difference in terms of energy consumption&lt;/strong&gt;, specially when considering Haskell’s primitives for thread management. In one of our benchmarks, &lt;a href=&quot;http://benchmarksgame.alioth.debian.org/u64q/performance.php?test=spectralnorm&quot;&gt;spectralnorm&lt;/a&gt;, using &lt;code&gt;forkOn&lt;/code&gt; with &lt;code&gt;TVar&lt;/code&gt; to create new threads, instead of &lt;code&gt;forkOS&lt;/code&gt;, can save between 25 and 57% energy. The graph below presents results for both time and energy for this benchmark, when varying the number of available virtual processors (capabilities) used by the Haskell runtime in a machine with 20 physical cores. We observed similar results, though not necessarily using the same thread management primitives, for 5 other concurrent benchmarks. This is very good news for developers. Switching between thread management primitives is very simple in Haskell. Functions &lt;code&gt;forkOn&lt;/code&gt;, &lt;code&gt;forkIO&lt;/code&gt;, and &lt;code&gt;forkOS&lt;/code&gt; take a computation of type &lt;code&gt;IO&lt;/code&gt; as parameter and produce results of the same type. Thus, the only difficulty is in determining on which capability a thread created via &lt;code&gt;forkOn&lt;/code&gt; will run. For most practical cases, this is a trivial decision.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://green-haskell.github.io/concurrency-results/?hide64=true&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/fernandocastor/fernandocastor.github.io/master/images/spectral-norm.png&quot; alt=&quot;The spectral-norm benchmark.&quot; title=&quot;http://green-haskell.github.io/concurrency-results/?hide64=true&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We observed a similar phenomenom for data-sharing constructs (&lt;code&gt;MVar&lt;/code&gt;, &lt;code&gt;TMVar&lt;/code&gt;, &lt;code&gt;TVar&lt;/code&gt;). In one of our benchmarks, under a specific configuration, &lt;strong&gt;choosing one data sharing construct, &lt;code&gt;MVar&lt;/code&gt;, over another, &lt;code&gt;TMVar&lt;/code&gt;, can yield 60% energy savings&lt;/strong&gt;. 
Nonetheless, neither for thread management primitives nor for data sharing constructs, there is a universal winner. The results vary depending on the characteristics of each program. In another benchmark, &lt;code&gt;TMVar&lt;/code&gt;s can yield up to 30% energy savings over &lt;code&gt;MVar&lt;/code&gt;s. Alternating between data sharing primitives is not as easy as doing so for thread management primitives, but still not hard, depending on the characteristics of the program to be refactored. Going from &lt;code&gt;MVar&lt;/code&gt; to &lt;code&gt;TMVar&lt;/code&gt; and back is straightforward because they have very similar semantics. For the transitions from &lt;code&gt;TMVar&lt;/code&gt; to &lt;code&gt;TVar&lt;/code&gt; and from &lt;code&gt;MVar&lt;/code&gt; to &lt;code&gt;TVar&lt;/code&gt;, things get trickier because the semantic distance from &lt;code&gt;TVar&lt;/code&gt; to the other two constructs when condition-based synchronization comes into play is considerable. In this case, it is possible that a more in-depth analysis of the program behavior will be necessary. Nonetheless, save for these trickier cases, tools that support developers in quickly refactoring a program to switch between different primitives can be of great help if energy is a concern.&lt;/p&gt;

&lt;p&gt;In addition, the relationship between energy consumption and performance is not always clear. Generally, specially &lt;strong&gt;in the sequential benchmarks, &lt;a href=&quot;http://green-haskell.github.io/data-structures-results/&quot;&gt;high performance is a proxy for low energy consumption&lt;/a&gt;&lt;/strong&gt;. Nonetheless, when concurrency comes into play, we found scenarios where the configuration with the best performance (30% faster than the one with the worst performance) also exhibited the second worst energy consumption (used 133% more energy than the one with the lowest usage). The following graphs illustrate this point in the context of the &lt;a href=&quot;http://benchmarksgame.alioth.debian.org/u64q/performance.php?test=fasta benchmark.&quot;&gt;fasta&lt;/a&gt;. In both cases, a lower value is better. In the graph on the left-hand side, depicting performance, the lines for the &lt;code&gt;TVar&lt;/code&gt; variants of the benchmark are among the lowest ones. In the graph on the right-hand side, the lines for &lt;code&gt;TVar&lt;/code&gt; exhibit the highest values for energy consumption.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://green-haskell.github.io/concurrency-results/?hide64=true&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/fernandocastor/fernandocastor.github.io/master/images/fasta.png&quot; alt=&quot;The fasta benchmark.&quot; title=&quot;http://green-haskell.github.io/concurrency-results/?hide64=true&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To support developers in better understanding this complex relationship, &lt;strong&gt;we have extended two existing tools for performance analysis to make them energy-aware&lt;/strong&gt;. The first one is the &lt;a href=&quot;http://hackage.haskell.org/package/criterion&quot;&gt;Criterion&lt;/a&gt; benchmarking library, which we have employed extensively in the two studies. The second one is the profiler that comes with the Glasgow Haskell compiler. &lt;/p&gt;

&lt;p&gt;The data for this study, as well as the source code for the implemented tools can be found &lt;a href=&quot;http://green-haskell.github.io&quot;&gt;here&lt;/a&gt;. We will soon make a preprint of our paper available. If you’re interested, don’t hesitate to contact us.&lt;/p&gt;

&lt;h4 id=&quot;references&quot;&gt;References&lt;/h4&gt;

&lt;p&gt;[1] V. Tiwari, S. Malik, and A. Wolfe, ``Power analysis of embedded software: a first step towards software power minimization’’, Very Large Scale Integration (VLSI) Systems, IEEE Transactions on, vol. 2, no. 4, pp. 437-445, Dec 1994.&lt;/p&gt;

&lt;p&gt;[2] C. Sahin, P. Tornquist, R. Mckenna, Z. Pearson, and J. Clause, ``How does code obfuscation impact energy usage?’’. In 30th IEEE International Conference on Software Maintenance and Evolution, Victoria, BC, Canada, September 29 - October 3, 2014, 2014, pp. 131-140.&lt;/p&gt;

&lt;p&gt;[3] M. L. Vasquez, G. Bavota, C. Bernal-Cardenas, R. Oliveto, M. D. Penta, and D. Poshyvanyk, ``Mining energy-greedy API usage patterns in android apps: an empirical study’’. In 11th Working Conference on Mining Software Repositories, MSR 2014, Proceedings, May 31 - June 1, 2014, Hyderabad, India, 2014, pp. 2-11.&lt;/p&gt;

&lt;p&gt;[4] C. Sahin, L. Pollock, and J. Clause, ``How do code refactorings affect energy usage?’’. In Proceedings of the 8th ACM/IEEE International Symposium on Empirical Software Engineering and Measurement, 2014, pp. 36:1-36:10.&lt;/p&gt;

&lt;p&gt;[5] G. Pinto, F. Castor, and Y. D. Liu, ``Understanding energy behaviors of thread management constructs’’, In Proceedings of the 2014. ACM International Conference on Object Oriented Programming Systems Languages &amp;amp; Applications. Portland, USA, 2014, pp. 345-360. &lt;/p&gt;

&lt;p&gt;[6] K. Liu, G. Pinto, and Y. Liu, ``Data-oriented characterization of application-level energy optimization’’. In Proceedings of the 18th In-
ternational Conference on Fundamental Approaches to Software Engineering, LNCS vol. 9033, 2015, pp. 316-331.&lt;/p&gt;

&lt;p&gt;[7] A. E. Trefethen and J. Thiyagalingam, ``Energy-aware software: Challenges, opportunities and strategies’’. Journal of Computational Science, vol. 4, no. 6, pp. 444 - 449, 2013.&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Nov 2015 20:00:00 -0300</pubDate>
        <link>http://fernandocastor.github.io/general/2015/11/19/green-haskell.html</link>
        <guid isPermaLink="true">http://fernandocastor.github.io/general/2015/11/19/green-haskell.html</guid>
        
        
        <category>general</category>
        
      </item>
    
      <item>
        <title>A very brief overview of Program Synthesis</title>
        <description>&lt;p&gt;Starting a couple of months ago, &lt;a href=&quot;http://www.cin.ufpe.br/&quot;&gt;CIn&lt;/a&gt;-&lt;a href=&quot;http://www.ufpe.br&quot;&gt;UFPE&lt;/a&gt;’s Software Engineering Laboratory started organizing  seminars given by its members. The goal is to make laboratory members aware of work being conducted by other members. So far, I’ve greatly enjoyed these seminars. In one of them, I learned a bit about cloud computing and also about electronic government (which seems to be an area of research that sits between Computer Science and Political Science) from Prof. &lt;a href=&quot;http://viniciusgarcia.com&quot;&gt;Vinicius Garcia&lt;/a&gt;. Last week we had one given by Prof. &lt;a href=&quot;https://sites.google.com/site/acmrecife/&quot;&gt;Alexandre Mota&lt;/a&gt;. One of the things I admire about Alexandre is that he is a hard core Formal Methods guy with a remarkable track record of collaboration with industry.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sites.google.com/site/acmrecife/&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/fernandocastor/fernandocastor.github.io/master/images/alexandre.jpg&quot; alt=&quot;Alexandre Mota presenting PSAtCIn&quot; title=&quot;https://sites.google.com/site/acmrecife/&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alexandre’s talk started with an overview of formal methods. According to Alexandre, formal methods are a combination of notations, tools, and a semantics based on mathematics. Their use can help developers to ascertain that there is no ambiguity, imprecision, inconsistency, and (for some systems) incompleteness in a system specification. This is the &lt;strong&gt;good&lt;/strong&gt; side of formal methods. The &lt;strong&gt;bad&lt;/strong&gt; side is that, to get from a specification to a correct system, there is a myriad different paths and each one of them is tough to traverse. And this is assuming that a formal specification exists. Going from an informal specification to a formal one is a very difficult problem in and of itself. It requires a thorough validation and the assistance of specialists.&lt;/p&gt;

&lt;p&gt;Alexandre also discussed the process of program refinement, going from a formal specification to executable code in a way that guarantees that the generated code satisfies the specification. According to him, there are two paths to go from formal specification to a correct system: (i) by data and operation refinement; and (ii) by &lt;a href=&quot;http://www.cs.ox.ac.uk/publications/books/PfS/&quot;&gt;refinement calculus&lt;/a&gt; (using a set of refinement rules). In the former approach, we’re transitioning from a specification &lt;em&gt;S0&lt;/em&gt; to a specification &lt;em&gt;S1&lt;/em&gt; and &lt;em&gt;S1&lt;/em&gt; is not determined by pre-established laws. One needs to propose and verify each refinement. It is possible to apply more broad-scoped transformations using this approach. In the latter, the transformations one can apply to the specification are constrained by the laws one is using. This is good because the proof obligations are relatively straightforward. The bad part is that it is more constraining and requires very experienced engineers. The “search” in refinement calculus may never end. Both approaches require searching for the specifications and for the theorems that must be proved. It is a search problem and leads us to the problem of program synthesis.&lt;/p&gt;

&lt;p&gt;After presenting a (critical) view of formal methods, he narrowed down the scope of his talk, focusing more on the subject of program synthesis. The problem of program synthesis can be summarized as follows: Build a system that, given a specification and optionally a set of program fragments, produces as output a program that satisfies (&lt;em&gt;refines&lt;/em&gt;?) the given specification and also includes the given program fragments. Program synthesis is a search problem because a large part of the work performed by a program synthesis system consists of searching through a space of candidate programs and checking whether they satisfy the specification. This problem is tough. In fact, part of it usually involves solving &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_satisfiability_problem&quot;&gt;SAT&lt;/a&gt;, the most famous &lt;a href=&quot;https://en.wikipedia.org/wiki/NP-completeness&quot;&gt;NP-complete&lt;/a&gt; problem. “Usually” because, when one is using a probabilistic approach for program synthesis, this is not the case.&lt;/p&gt;

&lt;p&gt;The area of program synthesis started a long time ago, before computers. In 1932, famous soviet mathematician &lt;a href=&quot;https://en.wikipedia.org/wiki/Andrey_Kolmogorov&quot;&gt;Andrey Kolmogorov&lt;/a&gt; already talked about algorithms with proofs that come from constructive mathematics. This is very distant from what is currently discussed as program synthesis. A particularly important system in this area, which appeared much latter, was the &lt;a href=&quot;http://www.kestrel.edu/home/projects/kids/&quot;&gt;Kestrel Interactive Development System&lt;/a&gt; (KIDS). KIDS supported program synthesis from a complex program specification by means of a series of manually applied refinement steps (maybe it couldn’t be strictly called a program systhesis system) and, according to its homepage, has been used to develop many applications in such diverse areas as scheduling, combinatorial design, sorting and searching, computational geometry, pattern matching, and mathematical programming. KIDS came close to a commercial breakthrough, which is impressive.&lt;/p&gt;

&lt;p&gt;According to Alexandre, there are three main approaches to program synthesis:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Synthesizers that are specialized in a particular domain&lt;/strong&gt;. An example of such approaches is the use of the VHDL language to describe digital and mixed-signal systems. These approaches are scalable but constrained to specific kinds of systems.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Synthesizers that translate a particular language into SAT/SMT language&lt;/strong&gt;. This is a general purpose approach, but it usually focuses on specific problems, such as security. According to Alexandre, the &lt;a href=&quot;http://people.csail.mit.edu/asolar/&quot;&gt;Sketch&lt;/a&gt; system is one of the most proeminent examples of this approach. Given specification and a code fragment, Sketch fills in the code that the programmer did not provide. An example of the kind of fragment the Sketch receives is the following:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;harness&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doubleSketch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;??&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Synthesizers that take as input a general purpose high-level specification&lt;/strong&gt;. This is the line of work that Alexandre and his colleagues, such as &lt;a href=&quot;http://www.cin.ufpe.br/~jmi/&quot;&gt;Juliano Iyoda&lt;/a&gt; (also from CIn-UFPE), pursue. In this case, program synthesis takes as input the specification of the program to be synthesized and an optional set of code fragments and produces as a result a program in a language that has a formal semantics. The latter part is particularly relevant because, as long as a language has formal syntax and semantics, it can be combined with this approach. They proposed an approach and a tool implementing it, named PSAtCIn, that currently combines a DSL targeting C# code, &lt;a href=&quot;http://alloy.mit.edu/alloy/hola/&quot;&gt;Alloy*&lt;/a&gt;, and a formal specification language in an Ecplise Plugin that is already capable of producing code from general-purpose specifications. Here’s a very simple example of the kind of thing one can do with PSAtCIn. Given a specification&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Vars&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;requires&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ensures&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gcd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sketch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;it can generate the program&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-csharp&quot; data-lang=&quot;csharp&quot;&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the specification part, &lt;code&gt;gcd&lt;/code&gt; is a logical predicate. &lt;/p&gt;

&lt;p&gt;Alexandre explained that this approach is currently capable of generating simple programs that include loops, e.g., it was capable of generating &lt;a href=&quot;https://en.wikipedia.org/wiki/Euclidean_algorithm&quot;&gt;Euclid’s algorithm&lt;/a&gt; for the greatest common divisor. This is a promising result, since loops are a common stumbling point for program synthesis and verification techniques. PSAtCIn also supports sketching (similarly to Sketch) and it is extensible for other languages that have formal syntax and semantics.&lt;/p&gt;

&lt;p&gt;Finally, Alexandre discussed some current challenges. The one that caught my attention was the recommendation of scopes for search. Since PSAtCIn uses Alloy* under the hood, it also performs bounded scope search when verifying whether a program satisfies its intended properties (pre and postconditions). In Alloy*, users must specify the bounds for the search scope. Alexandre hopes that, in the near future, PSAtCIn will be able to provide this kind of information automatically in program synthesis.&lt;/p&gt;
</description>
        <pubDate>Tue, 10 Nov 2015 09:39:06 -0300</pubDate>
        <link>http://fernandocastor.github.io/general/2015/11/10/program_synthesis.html</link>
        <guid isPermaLink="true">http://fernandocastor.github.io/general/2015/11/10/program_synthesis.html</guid>
        
        
        <category>general</category>
        
      </item>
    
      <item>
        <title>Two very interesting empirical studies presented at SPLASH&#39;2015</title>
        <description>&lt;p&gt;Today at &lt;a href=&quot;http://www.splashcon.com&quot;&gt;SPLASH&lt;/a&gt;, there was an OOPSLA session on empirical studies. All the four papers of the session were very interesting and well-presented. Two of them caught my attention because they are more related to work I have conducted in the past [&lt;a href=&quot;https://sites.google.com/a/cin.ufpe.br/castor/Pinto_2015_LSS_JSS.pdf?attredirects=0&amp;amp;d=1&quot;&gt;1&lt;/a&gt;,&lt;a href=&quot;https://sites.google.com/a/cin.ufpe.br/castor/msr_2015_submitted.pdf?attredirects=0&amp;amp;d=1&quot;&gt;2&lt;/a&gt;,&lt;a href=&quot;https://sites.google.com/a/cin.ufpe.br/castor/msr_2014_cr.pdf?attredirects=0&amp;amp;d=1&quot;&gt;3&lt;/a&gt;,&lt;a href=&quot;https://sites.google.com/a/cin.ufpe.br/castor/Ebert_2015_ESE_JSS.pdf?attredirects=0&amp;amp;d=1&quot;&gt;4&lt;/a&gt;]. I discuss them below.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://2015.splashcon.org&quot;&gt;&lt;img src=&quot;http://www.dynamic-languages-symposium.org/dls-15/media/splash15_logo.png&quot; alt=&quot;SPLASH&#39;2015 logo&quot; title=&quot;2015.splashcon.org&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;how-scale-affects-structure-in-java-programshttpdlacmorgcitationcfmid2814300cfid555774425cftoken10047354-by-crista-lopes-joel-ossher&quot;&gt;&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=2814300&amp;amp;CFID=555774425&amp;amp;CFTOKEN=10047354&quot;&gt;How Scale Affects Structure in Java Programs&lt;/a&gt; by Crista Lopes, Joel Ossher&lt;/h4&gt;

&lt;p&gt;I was already familiar with this paper, having discussed it with some students in &lt;a href=&quot;http://twiki.cin.ufpe.br/twiki/bin/view/TAES/TAES2201502&quot;&gt;class&lt;/a&gt; a couple of weeks ago. It is a very interesting piece of work showing how the size of a software system is correlated with certain characteristics (nothing new there) but also showing that &lt;strong&gt;this relationship changes as the size of a system grows&lt;/strong&gt; (previously an &lt;strong&gt;unverified&lt;/strong&gt; hypothesis, at least on a large scale study). This is strongly related to the 1975 &lt;a href=&quot;https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=2&amp;amp;cad=rja&amp;amp;uact=8&amp;amp;ved=0CCgQFjABahUKEwjAmfvx8-rIAhWF1h4KHZCdAvY&amp;amp;url=http%3A%2F%2Fwww.cs.umd.edu%2Fclass%2Fspring2005%2Fcmsc838p%2FGeneral%2Fpitl.pdf&amp;amp;usg=AFQjCNH4ihfX6lE2HK9tVhJUm9-7lIEG4g&amp;amp;sig2=A_ORzeazyaS54QTxN63rbg&quot;&gt;paper&lt;/a&gt; by DeRemer and Kron. The first sentence of this classifical paper summarizes its ideas very well: &lt;em&gt;“We distinguish the activity of writing large programs from that of writing small ones”&lt;/em&gt;. Lopes and Ossher’s study provides a considerable amount of data showing that this idea is verifiable. &lt;/p&gt;

&lt;p&gt;I also like how the paper emphasizes the importance of &lt;strong&gt;studying non-linear relationships&lt;/strong&gt; between variables pertaining to programs. For example, the study reports that the number of lines of code (LoC) in a program grows exponentially with respect to the number of modules (classes + interfaces), even though the exponent is small (1.0939). Thus as the paper itself explains, if a program with 10 modules has 400 LoC, we can expect a program with 100 modules to have 4965 LoC, instead of just 4000. Of course, this is a general trend and not something that will be observed for every program. Nonetheless, the observed data comprises more than 30.000 Java projects. This number suggests that the findings are robust and not likely to stem from chance. &lt;/p&gt;

&lt;p&gt;It is important to point out that the paper only investigated one &lt;strong&gt;software population&lt;/strong&gt;, that of Java projects hosted on Google Code until 2012. This does not necessarily reflect the characteristics of populations from other forges or based on different programming languages. Moreover, the study did not investigate the temporal dimension of these relationships. These are great news for researchers interested in this topic!&lt;/p&gt;

&lt;h4 id=&quot;use-at-your-own-risk-the-java-unsafe-api-in-the-wildhttpdlacmorgcitationcfmid2814313cfid555774425cftoken10047354-by-luis-mastrangelo-luca-ponzanelli-andrea-mocci-michele-lanza-matthias-hauswirth-nathaniel-nystrom&quot;&gt;&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=2814313&amp;amp;CFID=555774425&amp;amp;CFTOKEN=10047354&quot;&gt;Use at Your Own Risk: The Java Unsafe API in the Wild&lt;/a&gt; by Luis Mastrangelo, Luca Ponzanelli, Andrea Mocci, Michele Lanza, Matthias Hauswirth, Nathaniel Nystrom&lt;/h4&gt;

&lt;p&gt;This paper investigates one of those not-well-known, dirty little secrets. Java is type safe (and &lt;a href=&quot;http://research.microsoft.com/apps/pubs/default.aspx?id=68466&quot;&gt;type sound&lt;/a&gt;) and memory safe. This means that problems that stop an application from proceeding at runtime should be signaled as &lt;code&gt;Exception&lt;/code&gt;s or, in the worst case scenario (e.g., due to lack of heap space), as an &lt;code&gt;Error&lt;/code&gt;. Thus, in theory, one should never be able to crash the JVM. However, Java has this API, &lt;code&gt;sun.misc.Unsafe&lt;/code&gt; which, as the name implies, is not safe. This means that it is capable of performing operations that violate Java’s safety guarantees. Operations that allow one, for example, to affect memory alignment and to allocate memory without initializing an object. &lt;/p&gt;

&lt;p&gt;The study of Mastrangelo and colleagues was exploratory in nature. It aimed to assess the extent to which &lt;code&gt;Unsafe&lt;/code&gt; is used and how it is used. For that end, they used Apache’s Maven Central Repository as the data source. This repository has more than 950,000 artifacts (the results of builds). Considering only the latest versions of the artifacts and filtering out the undesired ones, they ended up with a corpus of 86479 artifacts amounting to 74GB of data. Among these artifacts, 817 use &lt;code&gt;Unsafe&lt;/code&gt;, less than 1%. This low number led the authors to investigate whether these artifacts are widely used or if they are isolated pieces of software. As it turns out, large-scale, well-known projects employ them. Notable examples include Scala, Ruby, Spring, Hibernate, Grails, Stream, Cassandra, Hadoop, Akka, Storm, and Neo4J. In their corpus, 21,297 artifacts indirectly use &lt;code&gt;Unsafe&lt;/code&gt;, almost 25% of all the analyzed artifacts. It is not clear to me whether “indirectly” means transitively or with just one level of indirection. I’ll have to check that out in the paper later. &lt;/p&gt;

&lt;p&gt;Proceeding with the analysis, they investigated which features of &lt;code&gt;Unsafe&lt;/code&gt; are often used and why. Examples include instructions to (i) query the memory layout; (ii) put and get elements in specific memory locations, e.g., in the heap; and (iii) compare-and-set instructions, which are very important for concurrent applications. These instructions are often used to improve performance. The authors documented 14 usage patterns, including processing of byte arrays in block, the aforementioned atomic operations and, amazingly, &lt;strong&gt;updates to &lt;code&gt;final&lt;/code&gt; fields&lt;/strong&gt;! The authors also analyzed questions that developers ask about &lt;code&gt;Unsafe&lt;/code&gt; at &lt;a href=&quot;http://www.stackoverflow.com&quot;&gt;StackOverflow&lt;/a&gt;. There don’t seem to be many questions on the topic, which is not surprising. The authors found out that lack of documentation is an important problem, though.&lt;/p&gt;

&lt;p&gt;This left me (and at least another member of the audience, it seems) wondering about which parts of &lt;code&gt;Unsafe&lt;/code&gt; are unsafe-r. The authors did not go that far, however. I’m not sure there is enough data to conduct that study yet.&lt;/p&gt;

&lt;h4 id=&quot;the-bottom-line&quot;&gt;The bottom line&lt;/h4&gt;

&lt;p&gt;Both studies raise new avenues for research, as I have discussed previously. In particular, for the first study, it would be interesting to (i) replicate it with different populations; (ii) examine the temporal dimension and how the discovered relationships change throughout system versions; (iii) examine different attributes, e.g., usage of constructs related to concurrency or testing. For the second one, I can imagine a number of controlled experiments focusing on the usage of &lt;code&gt;Unsafe&lt;/code&gt; features and examination of bug reports (for a large number of systems) in an attempt to identify the unsafe-st parts of the API.&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Oct 2015 11:54:06 -0300</pubDate>
        <link>http://fernandocastor.github.io/general/2015/10/30/unsafe-java-api.html</link>
        <guid isPermaLink="true">http://fernandocastor.github.io/general/2015/10/30/unsafe-java-api.html</guid>
        
        
        <category>general</category>
        
      </item>
    
      <item>
        <title>The most popular questions about concurrency on StackOverflow</title>
        <description>&lt;p&gt;We (mainly &lt;a href=&quot;http://www.gustavopinto.org&quot;&gt;Gustavo Pinto&lt;/a&gt;, with a little help from &lt;a href=&quot;https://sites.google.com/a/cin.ufpe.br/castor/&quot;&gt;myself&lt;/a&gt; and &lt;a href=&quot;https://twitter.com/weslleytorres&quot;&gt;Weslley Torres&lt;/a&gt;) have conducted a study on the most popular questions about concurrent programming on &lt;a href=&quot;http://www.stackoverflow.com&quot;&gt;StackOverflow&lt;/a&gt;. Our goal with this study was to understand the practical problems faced by software developers when using concurrent programming abstractions. These are the 10 most popular questions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/588866/&quot;&gt;Q588866&lt;/a&gt; “What’s the difference between the atomic and nonatomic attributes?”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/541487/&quot;&gt;Q541487&lt;/a&gt; “‘implements Runnable’ vs. ‘extends Thread’”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/6319146/&quot;&gt;Q6319146&lt;/a&gt; “C++11 introduced a standardized memory model. What does it mean? And how is it going to affect C++ programming?”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/200469/&quot;&gt;Q200469&lt;/a&gt; “What is the difference between a process and a thread”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/661561/&quot;&gt;Q661561&lt;/a&gt; “How to update the GUI from another thread in C#?”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/1036754/&quot;&gt;Q1036754&lt;/a&gt; “Difference between wait() and sleep()”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/62814/&quot;&gt;Q62814&lt;/a&gt; “Difference between binary semaphore and mutex”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/817856/&quot;&gt;Q817856&lt;/a&gt; “When and how should I use a ThreadLocal variable?”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/510632/&quot;&gt;Q510632&lt;/a&gt; “What’s the difference between ConcurrentHashMap and Collections.synchronizedMap(Map)?”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/323972/&quot;&gt;Q323972&lt;/a&gt; “Is there any way to kill a Thread in Python?”&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Among the top 10, we have questions specific to Objective-C (1), Java (2,6,9), C++ (3), C# (5), and Python (10). There are also a couple of questions asking about general concepts (3,7) and one that may be thought of as language specific or not (8). &lt;/p&gt;

&lt;h2 id=&quot;what-are-concurrency-related-questions&quot;&gt;What are concurrency-related questions?&lt;/h2&gt;
&lt;p&gt;We used the same keywords as the well-known &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=1346323&quot;&gt;study&lt;/a&gt; by Shan Lu and colleagues to select the questions based on the tags associated to them: “race(s)”, “deadlock(s)”, “livelock(s)”, “concurrency”, “lock(s)”, “mutex(es)”, “atomic”, “compete(s)”, and “multithreading”.&lt;/p&gt;

&lt;p&gt;This produced a list with more than 22000 questions. We then ranked them by popularity, extracted only the 250 most popular, and manually inspected those to ascertain that they were actually concurrency-related. We ended up with 231 questions.&lt;/p&gt;

&lt;h2 id=&quot;how-did-we-measure-popularity&quot;&gt;How did we measure popularity?&lt;/h2&gt;
&lt;p&gt;To calculate the popularity of each question, we obtained, for each one: (i) number of up-votes; (ii) number of times the question is marked as favorite; (iii) number of views; (iv) number of comments; and (v) and number of answers. Each of these metrics was then normalized with respect to the average value considering all the questions in StackOverflow. The &lt;strong&gt;P&lt;/strong&gt; popularity measure is the result of calculating the geometric mean of these normalized metrics.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Most of the questions pertained to either Java (77) or C# (60). Also, 28 pertained to mobile computing, focusing on one of the most popular platforms: iOS (6), Android (7), and Windows Phone (15).&lt;/p&gt;

&lt;p&gt;We classified the questions in terms of 7 categories:  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Theoretical Concepts (59)
    &lt;ul&gt;
      &lt;li&gt;Q34510 “What is a race condition?”&lt;/li&gt;
      &lt;li&gt;Q588866 “What’s the difference between the atomic and nonatomic attributes?”&lt;/li&gt;
      &lt;li&gt;Q200469 “What is the difference between a process and a thread?”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Practical Concepts  (51)
    &lt;ul&gt;
      &lt;li&gt;Q817856 “When and how should I use a ThreadLocal variable?”&lt;/li&gt;
      &lt;li&gt;Q154551 “Which [synchronization] approach should be used [to increment an int]?”&lt;/li&gt;
      &lt;li&gt;Q251391 “Why is lock(this) {. . . } bad?”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;First Steps (29)
    &lt;ul&gt;
      &lt;li&gt;Q2846653 “Trying to find a simple example that clearly shows a single task being divided for multi-threading.”&lt;/li&gt;
      &lt;li&gt;Q3360555 “How to pass parameters to ThreadStart method in Thread?”&lt;/li&gt;
      &lt;li&gt;Q2734025 “Is javascript guaranteed to be single-threaded?”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Thread Life-Cycle (18)
    &lt;ul&gt;
      &lt;li&gt;Q1520887 “How to pause / sleep thread or process in Android?”&lt;/li&gt;
      &lt;li&gt;Q323972 “Is there any way to kill a Thread in Python?”&lt;/li&gt;
      &lt;li&gt;Q289434 “How to make a Java thread wait for another thread’s output?”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Technical Problems (53)
    &lt;ul&gt;
      &lt;li&gt;Q661561 “How to update the GUI from another thread in C#?”&lt;/li&gt;
      &lt;li&gt;Q530211 “[How to] create a blocking Queue&lt;t&gt; in .NET?&quot;&lt;/t&gt;&lt;/li&gt;
      &lt;li&gt;Q16159203 “Why does this Java program terminate despite that apparently it shouldn’t (and didn’t)?”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Concurrent Lib/Framework (15 Q)
    &lt;ul&gt;
      &lt;li&gt;Q3629784 “How is Node.js inherently faster when it still relies on Threads internally?”&lt;/li&gt;
      &lt;li&gt;Q6916385 “Is there a concurrent List in Java’s JDK?”&lt;/li&gt;
      &lt;li&gt;Q3847108 “What is the Haskell response to Node.js?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Correctness (10 Q)
    &lt;ul&gt;
      &lt;li&gt;Q9666 “Is accessing a variable in C# an atomic operation?”&lt;/li&gt;
      &lt;li&gt;Q7095 “Is the C# constructor thread safe?”&lt;/li&gt;
      &lt;li&gt;Q680097 “I’ve heard i++ isn’t thread safe, is ++i thread-safe?”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Among all the questions, only one pertained to GPUs and not a single one asked specifically about improving performance, which is surprising. I could say that we learned three main things from this study: &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Developers do not understand the problems that existing tools report about concurrency errors, because they often do not understand the errors themselves. Error reports that provide actual code examples have a stronger potential to be useful (see the third point below)&lt;/li&gt;
  &lt;li&gt;Tools that help developers to build the software right, instead of trying to right the system after it’s built are useful. For example, a simple tool that indicates to developers which parts of the code execute atomically is straightforward to build and could be easily integrated into existing IDEs&lt;/li&gt;
  &lt;li&gt;Developers want examples, both minimal examples of things that work correctly and minimal examples of code that help them understand concurrency problems. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For more information, take a look at our &lt;a href=&quot;http://gustavopinto.org/lost+found/plateau2015.pdf&quot;&gt;paper&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Oct 2015 08:39:06 -0300</pubDate>
        <link>http://fernandocastor.github.io/concurrency/2015/10/28/the-most-popular-questions-on-stackoverflow.html</link>
        <guid isPermaLink="true">http://fernandocastor.github.io/concurrency/2015/10/28/the-most-popular-questions-on-stackoverflow.html</guid>
        
        
        <category>concurrency</category>
        
      </item>
    
      <item>
        <title>Haskell one-liner</title>
        <description>&lt;p&gt;One of these days, &lt;a href=&quot;http://www.twitter.com/1haskelladay&quot;&gt;@1HaskellADay&lt;/a&gt; posted the following programming challenge: &lt;/p&gt;

&lt;p&gt;&lt;em&gt;#1Liner You’re given either fst or snd, but don’t know which. Define a function that returns its dual: dual :: ((a,a) -&amp;gt; a) -&amp;gt; ((a,a) -&amp;gt; a)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;My answer to the challenge was fairly straightforward: &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;dual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It’s not bad, but nothing compared to &lt;a href=&quot;http://www.twitter.com/frsoares&quot;&gt;Francisco Soares&lt;/a&gt;’ &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;dual&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uncurry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flip&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curry&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This is how real Haskell programmers do it. Those that &lt;a href=&quot;http://www.bernstein-plus-sons.com/RPDEQ.html&quot; title=&quot;Real programmers don&#39;t eat quiche&quot;&gt;do not eat quiche&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Oct 2015 08:39:06 -0300</pubDate>
        <link>http://fernandocastor.github.io/general/2015/10/26/haskell-one-liner.html</link>
        <guid isPermaLink="true">http://fernandocastor.github.io/general/2015/10/26/haskell-one-liner.html</guid>
        
        
        <category>general</category>
        
      </item>
    
  </channel>
</rss>
