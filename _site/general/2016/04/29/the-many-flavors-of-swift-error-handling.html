<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>The Many Flavors of Swift's Error Handling Constructs</title>
  <meta name="description" content="While reading tutorials and other forms of documentation about Swift’s error handling mechanism, I noticed that most of them are superficial. Two notable exc...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://fernandocastor.github.io/general/2016/04/29/the-many-flavors-of-swift-error-handling.html">
  <link rel="alternate" type="application/rss+xml" title="Fernando Castor's rants" href="http://fernandocastor.github.io/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Fernando Castor's rants</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">The Many Flavors of Swift's Error Handling Constructs</h1>
    <p class="post-meta">Apr 29, 2016</p>
  </header>

  <article class="post-content">
    <p>While reading tutorials and other forms of documentation about Swift’s error handling mechanism, I noticed that most of them are superficial. Two notable exceptions are the <a href="https://realm.io/news/testing-swift-error-type/">exploration</a> of the <code>ErrorType</code> protocol that <a href="https://twitter.com/mrackwitz">Marcus Rackwitz</a> performed and the <a href="https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst">document</a> presenting the rationale and proposal for Swift error handling. Nevertheless, I couldn’t find a single place that presents the numerous ways in which Swift programmers can define, signal, and capture errors. Therefore I decided to analyze this in more depth. Here I attempt to summarize this investigation. I assume that you have at least a passing familiarity with exception handling in some other language and with the basic building blocks of Swift (classes, structs, enums).</p>

<p>It is important to stress that this post received more than a few contributions from <a href="https://twitter.com/frsoares">Francisco Soares</a>.</p>

<h3 id="the-required-swift-error-handling-primer">The Required Swift Error Handling Primer</h3>

<p>If you’ve ever developed a program in a language that includes an exception handling mechanism, e.g., Java, C#, Ruby, C++, Python, among so many others, Swift error handling is straightforward. Errors are values of types that conform to the <code>ErrorType</code> protocol, which will become <code>ErrorProtocol</code> in Swift 3.0. The <code>throw</code> statement signals the occurrence of an error. A method that signals an error has two options: (i) either it <code>catch</code>es the error; or (ii) it indicates in its signature that it <code>throws</code> an error. Most tutorials I’ve found on error handling in Swift start out by explaining that it is easy to define errors using an <code>enum</code>, for example:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">enum</span> <span class="nl">IOError</span> <span class="p">:</span> <span class="n">ErrorType</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">FileNotFound</span><span class="p">(</span><span class="nl">filePath</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">ConnectionTimedOut</span>
  <span class="k">case</span> <span class="n">ExceededNumberOfRetries</span><span class="p">(</span><span class="nl">number</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>

<p><code>IOError</code> is an enum with three enumeration cases (or constructors, if you come from a functional programming background). Each of these cases represents a different kind of error, as its name indicates. <code>ExceededNumberOfRetries</code> and <code>FileNotFound</code> are particularly interesting because they are errors that carry contextual information, the name of the file that was not found and the number of retries that were attempted before the error was signaled, respectively. This information can be employed to capture errors in more specific situations. Since each case is a value that represents an error, it can be <code>throw</code>n:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">readFromFile</span><span class="p">(</span><span class="nl">path</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="n">throws</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="bp">NSFileManager</span><span class="p">.</span><span class="n">defaultManager</span><span class="p">().</span><span class="n">fileExistsAtPath</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">throw</span> <span class="n">IOError</span><span class="p">.</span><span class="n">FileNotFound</span><span class="p">(</span><span class="nl">filePath</span><span class="p">:</span> <span class="n">path</span><span class="p">)</span> <span class="c1">// throws an error!</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="p">...</span> <span class="c1">// do something useful here.</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>The <code>throws</code> clause in the signature of <code>readFromFile</code> is required by the Swift compiler. Methods invoking <code>readFromFile</code> must either also have a <code>throws</code> clause in their signatures or explicitly <code>catch</code> the error. In addition, calls to <code>readFromFile</code> must be preceded by the <code>try</code> keyword to explicitly indicate that those statements may throw an error. The code snippet below presents an example of a method that invokes <code>readFromFile</code> and <code>catch</code>es the  <code>FileNotFound</code> error (and others, as explained below).</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">processText</span><span class="p">(</span><span class="nl">filePath</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">fileContents</span> <span class="o">=</span> <span class="n">try</span> <span class="n">readFromFile</span><span class="p">(</span><span class="nl">path</span><span class="p">:</span> <span class="n">filePath</span><span class="p">)</span>
    <span class="p">...</span> <span class="c1">// do something useful here</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="n">IOError</span><span class="p">.</span><span class="n">FileNotFound</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;File not found: \(filePath).&quot;</span><span class="p">)</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>To catch an error, it is necessary to place the code that may throw errors within a <code>do</code> block. That block can have one or more associated <code>catch</code> clauses. The code snippet above has two such clauses. The first one catches <code>FileNotFound</code> errors, whereas the second one catches any other error. The latter is required by Swift to guarantee that any other errors are also caught. The first <code>catch</code> clause does not specify the name of the file that triggered the error. I come back to this topic later. In the second block, <code>error</code> is a predefined variable that represents the caught error. It is accessible within the body of the generic <code>catch</code> block.</p>

<p>Swift has additional constructs for error handling. It is possible to write <code>try?</code> before an expression that may throw an error to convert the error into an optional value.<br />
As pointed out in Apple’s <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html">tutorial</a> on error handling in Swift, this construct is syntactic sugar for a common pattern of usage of <code>do-catch</code> blocks.
On the other hand, errors thrown by an expression preceded by <code>try!</code> are turned into a runtime error, more specifically, the same one that occurs when attempting to dereference <code>nil</code>. These errors cannot be captured by Swift. Hereafter I do not cover the use of either construct.</p>

<h3 id="many-flavors">Many Flavors</h3>

<p>There are many different approaches to define errors in Swift. Values of any type can be used as errors since even predefined types can be made to conform to <code>ErrorType</code> by means of extensions. Moreover, these approaches to define errors induce different methods to capture them. In this section I talk about both, definition and capture of errors.</p>

<h4 id="enumerations">Enumerations</h4>

<p>The previous section covered only one approach to define errors, namely, to create an enumeration that conforms to the <code>ErrorType</code> protocol, and one to catch errors, using pattern matching on the enumeration cases. In the above example, to add another <code>catch</code> clause for the <code>ExceededNumberOfRetries</code> case, we could do so for a specific number of retries, as follows:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">processText</span><span class="p">(</span><span class="nl">filePath</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// same as before, including first catch clause</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="n">IOError</span><span class="p">.</span><span class="n">ExceededNumberOfRetries</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// do something when number of retries is one  </span>
  <span class="p">}</span> <span class="n">catch</span> <span class="n">IOError</span><span class="p">.</span><span class="n">ExceededNumberOfRetries</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// do something when number of retries is something other than 1  </span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>In this example, the first <code>catch</code> clause will be selected when the <code>ExceededNumberOfRetries</code> error is constructed with argument 1. In the second one, an <code>ExceededNumberOfRetries</code> error will be caught independently of the argument. Since <code>catch</code> clauses are analyzed in textual order at runtime, there is no danger of the first one not being selected when it should be.</p>

<p>The possibility of describing very specific conditions for capturing an error (it is also possible to add a <code>where</code> clause to a <code>catch</code> clause to specify a boolean condition) highlights an important difference between Swift and some statically-typed languages that make extensive use of exception handling mechanisms: error capture in the examples we have seen so far is by value and not by type (it’s pattern matching, after all). This is the reason why the last <code>catch</code> clause associated with a <code>do</code> block must always be generic. It is not possible to statically guarantee the absence of uncaught errors when capturing errors by pattern matching without such generic <code>catch</code> clause.</p>

<h4 id="classes">Classes</h4>

<p>In this section I examine the use of classes to define errors. For this case, we will redefine <code>ExceededNumberOfRetries</code> and <code>FileNotFound</code> as classes that are subtypes of another class named <code>IOError</code>.  The latter conforms to the <code>ErrorType</code> protocol. This structure is presented below.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">class</span> <span class="nl">IOError</span> <span class="p">:</span> <span class="n">ErrorType</span> <span class="p">{}</span>
<span class="k">class</span> <span class="nl">ExceededNumberOfRetries</span> <span class="p">:</span> <span class="n">IOError</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nl">numRetries</span> <span class="p">:</span> <span class="n">Int</span>
  <span class="k">init</span><span class="p">(</span><span class="nl">num</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span> <span class="n">numRetries</span> <span class="o">=</span> <span class="n">num</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nl">FileNotFound</span> <span class="p">:</span> <span class="n">IOError</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nl">path</span> <span class="p">:</span> <span class="n">String</span>
  <span class="k">init</span><span class="p">(</span><span class="nl">filePath</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span> <span class="n">path</span> <span class="o">=</span> <span class="n">filePath</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>To use the class definitions above, the only change that needs to be applied to the <code>readFromFile</code> function is that the <code>IOError.</code> prefix must be removed from the line that throws the error. This is necessary because <code>FileNotFound</code> is now a full-fledged type, instead of just an enumeration case for <code>IOError</code>. For function <code>processText</code>, modifications are necessary because Swift does not know, by default, how to pattern match on values that are instances of classes. However, it is also possible to capture errors by type in Swift, more similarly to how it’s done in Java and C#. Nevertheless, it is important to bear in mind that, behind the scenes, it’s still pattern matching.
The following example is a modified version of the first version of <code>processText</code>, adapted to work with this approach:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">processText</span><span class="p">(</span><span class="nl">filePath</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// same as before</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="k">let</span> <span class="n">fileError</span> <span class="kt">as</span> <span class="n">FileNotFound</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;File not found: \(fileError.path).&quot;</span><span class="p">)</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>In the code snippet, the first <code>catch</code> clause and its body were modified. The <code>catch</code> clause now captures errors whose type is <code>FileNotFound</code> and binds them to variable <code>fileError</code>. The error value, an object, is then accessible within the <code>catch</code> block. If the captured error is not of that type, it is handled by the generic <code>catch</code> block. In case it is not necessary to access the error object within the <code>catch</code> blocks, one can use the <code>is</code> operator, which checks whether the value on the left has the type on its right, instead of as:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="p">...</span> <span class="c1">// same as before</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="kt">is</span> <span class="n">FileNotFound</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;File not found.&quot;</span><span class="p">)</span> <span class="c1">// error is not accessible</span>
  <span class="p">}</span>
<span class="p">...</span> <span class="c1">// same as before</span></code></pre></div>

<p>As usual for pattern matching, when capturing errors matching patterns by type it is important to keep <code>catch</code> clauses for more generic types after ones for more specific types. In the following example, the second <code>catch</code> clause will never be selected because the first one captures errors of type <code>IOError</code>, a superclass of <code>FileNotFound</code>.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">processText</span><span class="p">(</span><span class="nl">filePath</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// same as before</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="k">let</span> <span class="n">IOError</span> <span class="kt">as</span> <span class="n">IOError</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// handle the error</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="k">let</span> <span class="n">fileError</span> <span class="kt">as</span> <span class="n">FileNotFound</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// Will never be reached.</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<h4 id="structs">Structs</h4>

<p>Structs defining errors are similar to classes, with the differences that <code>IOError</code> must be a protocol, since inheritance between structs is not possible, and that initializers become unnecessary:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">protocol</span> <span class="nl">IOError2</span> <span class="p">:</span> <span class="n">ErrorType</span> <span class="p">{}</span>
<span class="k">struct</span> <span class="nl">ExceededNumberOfRetries</span> <span class="p">:</span> <span class="n">IOError</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nl">numRetries</span> <span class="p">:</span> <span class="n">Int</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="nl">FileNotFound</span> <span class="p">:</span> <span class="n">IOError</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nl">path</span> <span class="p">:</span> <span class="n">String</span>
<span class="p">}</span></code></pre></div>

<p>Using these definitions of the errors, function <code>processText</code> can be used as is, i.e., capturing errors by type. One relevant question is whether it is also possible to capture error structs based on their value. The short answer is yes (and the same applies to classes!), but with limitations.</p>

<p><a href="https://twitter.com/mrackwitz">Marcus Rackwitz</a>, in his  <a href="https://realm.io/news/testing-swift-error-type/">exploration</a> of the <code>ErrorType</code> protocol shows how one can pattern match with struct values to capture errors. Using the <a href="http://lldb.llvm.org/">LLDB</a> debugger for the <a href="http://www.llvm.org">LLVM</a> compiler infrastructure, he noticed that the <code>ErrorType</code> protocol is defined as follows, behind the scenes:  </p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">protocol</span> <span class="n">ErrorType</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nl">_domain</span><span class="p">:</span> <span class="n">Swift</span><span class="p">.</span><span class="n">String</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
  <span class="k">var</span> <span class="nl">_code</span><span class="p">:</span> <span class="n">Swift</span><span class="p">.</span><span class="n">Int</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<!---_ --->

<p>It is interesting to note that types conforming to this protocol do not need to define these properties. In order to capture errors by pattern matching on the error values, one needs to first define the struct representing errors and then overload the pattern matching operator (<code>~=</code>). The only downside is that it is only possible to pattern match using the properties defined by <code>ErrorType</code>, <code>_domain</code> and <code>_code</code>. Nevertheless, it is useful to avoid having to define a new struct type for each error, in case one wants to use structs or classes to define errors.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">struct</span> <span class="nl">Error</span> <span class="p">:</span> <span class="n">ErrorType</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nl">domain</span><span class="p">:</span> <span class="n">String</span>
    <span class="k">let</span> <span class="nl">code</span><span class="p">:</span> <span class="n">Int</span>    
    <span class="k">var</span> <span class="nl">_domain</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">domain</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nl">_code</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">code</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="o">~=</span><span class="p">(</span><span class="nl">lhs</span><span class="p">:</span> <span class="n">Error</span><span class="p">,</span> <span class="nl">rhs</span><span class="p">:</span> <span class="n">ErrorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">_domain</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">_domain</span>
        <span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">.</span><span class="n">_code</span>   <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">_code</span>
<span class="p">}</span></code></pre></div>

<!---_ --->

<p>With this scaffolding in place, it is possible to catch errors defined by structs based on the values of these two properties:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">processText</span><span class="p">(</span><span class="nl">filePath</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// same as before</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="n">Error</span><span class="p">(</span><span class="nl">domain</span><span class="p">:</span> <span class="s">&quot;FileNotFound&quot;</span><span class="p">,</span> <span class="nl">code</span><span class="p">:</span> <span class="mi">404</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// handle the error</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>The limitation of this approach is that it only employs the properties that exist in <code>ErrorType</code> for pattern matching, even if the struct has other properties. In the example below, the values of the new property <code>additionalInfo</code> of <code>Error</code> will not be taken into account by the <code>catch</code> clauses. The overload of <code>~=</code> cannot account for <code>additionalInfo</code>, since this property is not defined in <code>ErrorType</code>. Thus, the second <code>catch</code> clause will never be selected.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">struct</span> <span class="nl">Error</span> <span class="p">:</span> <span class="n">ErrorType</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// definitions of domain and code</span>
    <span class="k">let</span> <span class="nl">additionalInfo</span><span class="p">:</span> <span class="n">String</span>
    <span class="p">...</span> <span class="c1">// definitions of _domain and _code</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">processText</span><span class="p">(</span><span class="nl">filePath</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// same as before</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="n">Error</span><span class="p">(</span><span class="nl">domain</span><span class="p">:</span> <span class="s">&quot;FileNotFound&quot;</span><span class="p">,</span> <span class="nl">code</span><span class="p">:</span> <span class="mi">404</span><span class="p">,</span> <span class="nl">additionalInfo</span><span class="p">:</span> <span class="s">&quot;config.sys&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// handle the error</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="n">Error</span><span class="p">(</span><span class="nl">domain</span><span class="p">:</span> <span class="s">&quot;FileNotFound&quot;</span><span class="p">,</span> <span class="nl">code</span><span class="p">:</span> <span class="mi">404</span><span class="p">,</span> <span class="nl">additionalInfo</span><span class="p">:</span> <span class="s">&quot;autoexec.bat&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// handle the error</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<!---_ --->

<p>It is possible to use Swift’s forced cast operator (<code>as!</code>) to work around this limitation and  account for additional struct and class properties. It is only a matter of checking whether the second parameter of the pattern matching operator has the struct type (<code>Error</code>, in the examples) and, in case it does, force cast the argument from <code>ErrorType</code> to the struct type.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">struct</span> <span class="nl">Error</span> <span class="p">:</span> <span class="n">ErrorType</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nl">domain</span><span class="p">:</span> <span class="n">String</span>
    <span class="k">let</span> <span class="nl">code</span><span class="p">:</span> <span class="n">Int</span>    
    <span class="k">let</span> <span class="nl">additionalInfo</span> <span class="p">:</span> <span class="n">Int</span>
    <span class="k">var</span> <span class="nl">_domain</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">domain</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nl">_code</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">code</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="o">~=</span><span class="p">(</span><span class="nl">lhs</span><span class="p">:</span> <span class="n">Error</span><span class="p">,</span> <span class="nl">rhs</span><span class="p">:</span> <span class="n">ErrorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">result</span> <span class="o">=</span>  <span class="n">lhs</span><span class="p">.</span><span class="n">_domain</span> <span class="o">==</span> <span class="n">newRHS</span><span class="p">.</span><span class="n">_domain</span>
               <span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">.</span><span class="n">_code</span>   <span class="o">==</span> <span class="n">newRHS</span><span class="p">.</span><span class="n">_code</span>
    <span class="k">if</span> <span class="k">let</span> <span class="n">newRHS</span> <span class="o">=</span> <span class="n">rhs</span> <span class="kt">as</span><span class="o">?</span> <span class="n">Error</span> <span class="p">{</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">additionalInfo</span> <span class="o">==</span> <span class="n">newRHS</span><span class="p">.</span><span class="n">additionalInfo</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span></code></pre></div>

<!---_ --->

<p>With these definitions, any attribute from <code>Error</code> can be used for pattern matching when capturing errors. Thus, in the following example, the second <code>catch</code> clause will be selected normally.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">processText</span><span class="p">(</span><span class="nl">filePath</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// same as before</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="n">Error</span><span class="p">(</span><span class="nl">domain</span><span class="p">:</span> <span class="s">&quot;FileNotFound&quot;</span><span class="p">,</span> <span class="nl">code</span><span class="p">:</span> <span class="mi">404</span><span class="p">,</span> <span class="nl">additionalInfo</span><span class="p">:</span> <span class="s">&quot;autoexec.bat&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// handle the error</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="nf">processText</span><span class="p">(</span><span class="nl">filePath</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// same as before</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="n">Error</span><span class="p">(</span><span class="nl">domain</span><span class="p">:</span> <span class="s">&quot;FileNotFound&quot;</span><span class="p">,</span> <span class="nl">code</span><span class="p">:</span> <span class="mi">404</span><span class="p">,</span> <span class="nl">additionalInfo</span><span class="p">:</span> <span class="s">&quot;config.sys&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// handle the error</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="n">Error</span><span class="p">(</span><span class="nl">domain</span><span class="p">:</span> <span class="s">&quot;FileNotFound&quot;</span><span class="p">,</span> <span class="nl">code</span><span class="p">:</span> <span class="mi">404</span><span class="p">,</span> <span class="nl">additionalInfo</span><span class="p">:</span> <span class="s">&quot;autoexec.bat&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// handle the error</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>Swift 2.1.1 behaves non-intuitively when overloading the pattern matching operator for structs and classes. The code snippet below defines a struct and a class and makes both of them conform to <code>ErrorType</code>. It also overloads the pattern matching operator for both types (using just the <code>code</code> property). When executed, the program prints <em>“catch block for ErrorStruct”</em>, instead of <em>“catch block for ErrorClass”</em>, even though we are throwing <code>ErrorClass(code: 10)</code>. I assume that, under the hood, Swift invokes the overloaded version of <code>~=</code> that best matches the type of the error object. Since this implementation disregards the object type (it only looks at the value of <code>code</code>), the matching will depend only on the value of the <code>code</code> property.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">struct</span> <span class="nl">ErrorStruct</span> <span class="p">:</span> <span class="n">ErrorType</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nl">code</span> <span class="p">:</span> <span class="n">Int</span>
  <span class="k">var</span> <span class="nl">_code</span> <span class="p">:</span> <span class="n">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">code</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nl">ErrorClass</span> <span class="p">:</span> <span class="n">ErrorType</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nl">code</span> <span class="p">:</span> <span class="n">Int</span>
  <span class="k">var</span> <span class="nl">_code</span> <span class="p">:</span> <span class="n">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">code</span> <span class="p">}</span>

  <span class="k">init</span><span class="p">(</span><span class="nl">code</span> <span class="p">:</span><span class="n">Int</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="p">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">code</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="o">~=</span><span class="p">(</span><span class="nl">lhs</span><span class="p">:</span> <span class="n">ErrorClass</span><span class="p">,</span> <span class="nl">rhs</span><span class="p">:</span> <span class="n">ErrorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">_code</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">_code</span>
<span class="p">}</span>
<span class="k">func</span> <span class="o">~=</span><span class="p">(</span><span class="nl">lhs</span><span class="p">:</span> <span class="n">ErrorStruct</span><span class="p">,</span> <span class="nl">rhs</span><span class="p">:</span> <span class="n">ErrorType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">_code</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">_code</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">f</span><span class="p">()</span> <span class="n">throws</span> <span class="p">{</span>
  <span class="n">throw</span> <span class="n">ErrorClass</span><span class="p">(</span><span class="nl">code</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">g</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="n">try</span> <span class="n">f</span><span class="p">()</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="n">ErrorStruct</span><span class="p">(</span><span class="nl">code</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;catch block for ErrorStruct&quot;</span><span class="p">)</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="n">ErrorClass</span><span class="p">(</span><span class="nl">code</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;catch block for ErrorClass&quot;</span><span class="p">)</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
<span class="n">g</span><span class="p">()</span></code></pre></div>

<!---_ --->

<h4 id="nserror-and-other-predefined-types">NSError and other predefined types</h4>

<p>The traditional approach for Objective-C applications to signal errors is to return instances of the <code>NSError</code> class. This class seems to have a special status when it comes to throwing and capturing errors in Swift. It <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html">adopts</a> the <code>ErrorType</code> protocol, similarly to other types defining errors we have examined. However, a <code>catch</code> clause for <code>NSError</code> works as a generic <code>catch</code> clause. Thus, the following three <code>catch</code> clauses seem to be equivalent in the sense that any other two could be removed and the Swift compiler would still be satisfied. For the second case (<code>ErrorType</code>), Xcode emits a warning stating that <em>“as test is always true”</em>.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">processText</span><span class="p">(</span><span class="nl">filePath</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// same as before</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="k">let</span> <span class="n">error</span> <span class="kt">as</span> <span class="bp">NSError</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="n">error</span><span class="p">).</span><span class="s">&quot;)</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="k">let</span> <span class="n">error</span> <span class="kt">as</span> <span class="n">ErrorType</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="n">error</span><span class="p">).</span><span class="s">&quot;)</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>It is interesting to note that <code>NSError</code> already defines properties <code>code</code> and <code>domain</code>. Thus, to use pattern matching on value of type <code>NSError</code>, one needs only to redefine the <code>~=</code> operator as we have done in the previous section.</p>

<p>One relevant question is whether it is possible to throw instances of <code>NSException</code> using Swift’s <code>throw</code> statement. By default, <code>NSException</code> does not conform to <code>ErrorType</code>. Thus, its instances cannot be thrown. However, by extending it to make it adopt <code>ErrorType</code>, it becomes possible to both throw and capture errors of type <code>NSException</code>.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="c1">// errors of type NSException can now be thrown and caught as we&#39;ve seen before.</span>
<span class="k">extension</span> <span class="nl">NSException</span><span class="p">:</span> <span class="n">ErrorType</span> <span class="p">{</span> <span class="p">}</span></code></pre></div>

<p>Making <code>NSException</code> an error is not the same, though, as dealing with Objective-C exceptions. Errors thrown from Swift code are different from exceptions thrown from Objective-C code. The underlying mechanisms differ considerably. Moreover, Swift code cannot catch exceptions thrown from Objective-C, irrespective of <code>NSException</code> conforming to <code>ErrorType</code>.</p>

<p>As I’ve mentioned before, it is possible to extend any type to make it conform to <code>ErrorType</code>. This may lead to esoteric code that, for example, throws an integer:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">extension</span> <span class="nl">Int</span> <span class="p">:</span> <span class="n">ErrorType</span> <span class="p">{}</span>

<span class="k">func</span> <span class="n">readFromFile</span><span class="p">(</span><span class="nl">path</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="n">throws</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="bp">NSFileManager</span><span class="p">.</span><span class="n">defaultManager</span><span class="p">().</span><span class="n">fileExistsAtPath</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">throw</span> <span class="mi">42</span> <span class="c1">// throws an error!?</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// do something useful here.</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">processText</span><span class="p">(</span><span class="nl">filePath</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">fileContents</span> <span class="o">=</span> <span class="n">try</span> <span class="n">readFromFile</span><span class="p">(</span><span class="nl">path</span><span class="p">:</span> <span class="n">filePath</span><span class="p">)</span>
    <span class="p">...</span> <span class="c1">// do something useful here</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="n">error</span> <span class="kt">as</span> <span class="n">Int</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;The answer is \(error)&quot;</span><span class="p">)</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<h3 id="closing-comments">Closing comments</h3>

<p>Swift’s error handling mechanism is a breath of fresh air. It takes some well-established ideas, e.g., specific constructs to throw and handle errors and static checking for errors, and builds something truly unique out of them. However, the resulting mechanism is very flexible in that there are many different approaches to define and capture errors. In this post I have analyzed every possibility I could identify. I’d like to hear about other approaches, since I’m bound to have missed some.</p>

<h3 id="references">References</h3>

<ul>
  <li>
    <p><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html">Apple’s official documentation for Swift error handling</a></p>
  </li>
  <li>
    <p><a href="https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst">Rationale for the design of Swift’s error handling constructs. <strong>Very nice</strong>!</a></p>
  </li>
  <li>
    <p><a href="https://realm.io/news/testing-swift-error-type/">Careful exploration of Swift’s ErrorType protocol. Some interesting lessons to learn here</a></p>
  </li>
  <li>
    <p><a href="https://gist.github.com/nicklockwood/21495c2015fd2dda56cf">Well thought-out criticism of Swift’s error handing constructs, with an alternative proposal</a></p>
  </li>
  <li>
    <p><a href="http://stackoverflow.com/questions/24010569/error-handling-in-swift-language">A post on Swift error handling from StackOverflow</a></p>
  </li>
  <li>
    <p><a href="http://finestructure.co/blog/2015/6/18/swift-2-try-catch-under-the-hood">What happens with Swift error handling at the IL level? Somone has looked into it</a></p>
  </li>
  <li>
    <p><a href="https://www.bignerdranch.com/blog/error-handling-in-swift-2/">Swift error handling from the Big Nerd Ranch</a></p>
  </li>
  <li>
    <p><a href="http://code.tutsplus.com/tutorials/error-handling-in-swift-2--cms-25096">Nice tutorial covering a number of aspects of Swift error handling</a></p>
  </li>
  <li>
    <p><a href="https://appventure.me/2015/06/19/swift-try-catch-asynchronous-closures/">Using Swift’s error handling constructs with asynchronous closures</a></p>
  </li>
</ul>




<div id="disqus_thread"></div>
<script type="text/javascript">
/*

var disqus_config = function () {
this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

*/
var disqus_developer = 1;
var disqus_shortname = 'fernandocastor'; 
var disqus_identifier = "/general/2016/04/29/the-many-flavors-of-swift-error-handling.html";

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//fernandocastor.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>



         
  </article>

</div>

       
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

<!--    <h2 class="footer-heading">Fernando Castor's rants</h2> -->

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Fernando Castor's rants</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/fernandocastor">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">fernandocastor</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/fernandocastor">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">fernandocastor</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">The opinions expressed here are the sole responsibility of the author.
</p>
      </div>
    </div>

  </div>

</footer>

  <script id="dsq-count-scr" src="//fernandocastor.disqus.com/count.js" async></script>
  </body>

</html>
